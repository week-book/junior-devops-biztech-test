Ниже приведена полная "прорисовка" работы Insertion-Sort на массиве:

```
A = [3, 2, 1, 5]
```

для каждой итерации `j = 2, 3, 4`. В ячейках таблицы стрелками показано, как именно элементы "проталкиваются" вправо, чтобы освободить место для "ключа" (`key`).

|       j      |   A\[1]  |  A\[2]  |  A\[3]  | A\[4] |
| :----------: | :------: | :-----: | :-----: | :---: |
| **1 (Дано)** |     3    |    2    |    1    |   5   |
|     **2**    |  **2 ←** | **3 →** |    1    |   5   |
|     **3**    | **1 ←←** | **2 →** | **3 →** |   5   |
|     **4**    |     1    |    2    |    3    |   5   |

### Пояснение к итерациям:

* **j = 2**:

  * `key = A[2] = 2`, сравнивается с `A[1] = 3`.
  * Так как `2 < 3`, `3` сдвигается вправо, а `2` вставляется на место `A[1]`.
  * Массив становится `[2, 3, 1, 5]`.

* **j = 3**:

  * `key = A[3] = 1`, сравнивается с `A[2] = 3` → сдвигаем `3` вправо,
  * затем сравнивается с `A[1] = 2` → сдвигаем `2` вправо,
  * вставляем `1` в `A[1]`.
  * Массив становится `[1, 2, 3, 5]`.

* **j = 4**:

  * `key = A[4] = 5`, сравнивается с `A[3] = 3`, и так как `5 >= 3`, изменений не происходит.

**Итог:** окончательно отсортированный массив:

```
[1, 2, 3, 5]
```

